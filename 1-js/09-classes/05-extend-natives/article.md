
# Ընդլայնում ներկառուցված class-ներից 

Ներկառուցված class-ները, ինչպիսիք են Array-ը, Map-ը և այլն, նույնպես ընդլայնվող են:

Օրինակ՝ այստեղ `PowerArray`-ը ժառանգում է հարազատ `Array`-ից.

```js run
// ավելացնենք ևս մեկ մեթոդ (կարող է անել ավելին)
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr); // 10, 50
alert(filteredArr.isEmpty()); // false
```

Նկատի ունեցեք, կա մի շատ հետաքրքիր երևույթ։ Ներկառուցված մեթոդները, ինչպիսիք են `filter`, `map` և այլն, վերադարձնում են `PowerArray`-ից ճիշտ ժառանգված տիպով նոր օբյեկտներ: Դրանց ներքին իրագործումը դրա համար օգտագործում է օբյեկտի `constructor` հատկությունը:

Վերոնշյալ օրինակում՝
```js
arr.constructor === PowerArray
```

Երբ `arr.filter()`-ը կանչվում է, այն ներքին կարգով ստեղծում է արդյունքների նոր զանգված՝ օգտագործելով հենց `arr.constructor`-ը, ոչ թե հիմնական `Array`-ը: Դա իրականում հրաշալի է, քանի որ արդյունքում մենք կարող ենք շարունակել օգտագործել `PowerArray`-ի մեթոդները:

Ավելին, մենք կարող ենք կարգավորել այս վարքագիծը:

Մենք կարող ենք class-ին ավելացնել `Symbol.species` հատուկ ստատիկ գեթթեր: Եթե այն գոյություն ունի, ապա պետք է վերադարձնի այն կոնստրուկտորը, որը JavaScript-ը կօգտագործի ներքին կարգով՝ `map`, `filter` և այլնում նոր կազմավորումներ ստեղծելու համար:

Եթե մեզ անհրաժեշտ է, որ ներկառուցված մեթոդները, ինչպիսիք են `map`-ը կամ `filter`-ը, վերադարձնեն սովորական զանգվածներ, ապա կարող ենք վերադարձնել `Array`-ը `Symbol.species`-ում, այսպես.

```js run
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

*!*
  // ներկառուցված մեթոդները կօգտագործեն սա որպես կոնստրուկտոր
  static get [Symbol.species]() {
    return Array;
  }
*/!*
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

// filter-ը ստեղծում է նոր զանգված՝ օգտագործելով arr.constructor[Symbol.species]-ը որպես կոնստրուկտոր
let filteredArr = arr.filter(item => item >= 10);

*!*
// filteredArr-ը PowerArray չէ, այլ Array է
*/!*
alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function
```

Ինչպես տեսնում եք, այժմ `.filter`-ը վերադարձնում է `Array`-ը: Այսպիսով, ընդլայնված ֆունկցիոնալն այլևս չի փոխանցվում:

```smart header="Մյուս հավաքածուները նույն կերպ են աշխատում"
Մյուս հավաքածուները, ինչպիսիք են `Map`-ը և `Set`-ը, աշխատում են նույն կերպ: Դրանք նաև օգտագործում են `Symbol.species`:
```

## Ներկառուցված class-ներում ստատիկ ժառանգությունը բացակայում է

Ներկառուցված օբյեկտներն ունեն իրենց սեփական ստատիկ մեթոդները, օրինակ՝ `Object.keys`, `Array.isArray` և այլն․․․

Ինչպես արդեն գիտենք, հարազատ class-ները միմյանց ընդլայնում են։ Օրինակ՝ `Array`-ն ընդլայնում է `Object`-ը:

Սովորաբար, երբ մի class-ը ընդլայնում է մյուսին, և՛ ստատիկ, և՛ ոչ ստատիկ մեթոդները ժառանգվում են: Դա մանրամասնորեն բացատրվում է այս հոդվածում՝ [](info:static-properties-methods#statics-and-inheritance)։

Բայց ներկառուցված class-ները բացառություն են: Նրանք միմյանցից ստատիկներ չեն ժառանգում:

Օրինակ՝ և `Array`-ը, և `Date`-ը ժառանգում են `Object`-ից, այնպես որ դրանց նմուշներն ունեն մեթոդներ `Object.prototype`-ից: Բայց `Array.[[Prototype]]`-ը հղում չի անում `Object`-ին, ուստի, օրինակ՝ `Array.keys()`-ում (կամ `Date.keys()`-ում) ստատիկ մեթոդ չկա:

Ահա `Date`-ի և `Object`-ի պատկերավոր կառուցվածքը.

![](object-date-inheritance.svg)

Ինչպես տեսնում եք, `Date`-ի և `Object`-ի միջև կապ չկա: Նրանք անկախ են, միայն `Date.prototype`-ն է ժառանգում `Object.prototype`-ից:

Սա ներկառուցված օբյեկտների միջև ժառանգության կարևոր տարբերություն է այն բանի համեմատ, ինչ մենք ստանում ենք `extends`-ով:
