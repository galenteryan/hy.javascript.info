# Խառնուրդներ (mixins)

JavaScript-ում կարող ենք ժառանգել միայն մեկ օբյեկտից: Օբյեկտի համար կարող է լինել միայն մեկ `[[Prototype]]`: Եվ class-ը կարող է ընդլայնել միայն մեկ class:

Բայց, երբեմն դա սահմանափակ է թվում: Օրինակ՝ մենք ունենք `StreetSweeper` և `Bicycle` class-ներ, և ցանկանում ենք ստեղծել դրանց խառնուրդը՝ `StreetSweepingBicycle`:

Կամ, ունենք `User` class և `EventEmitter` class, որն իրագործում է իրադարձությունների ստեղծումը, և մեզ անհրաժեշտ է ավելացնել `EventEmitter`-ի ֆունկցիոնալը `User`-ում, որպեսզի մեր օգտվողները կարողանան ստեղծել իրադարձություններ:

Կա մի հասկացություն, որը կարող է օգնել մեզ այստեղ, դա կոչվում է «խառնուրդներ» (mixins):

Ինչպես սահմանված է Վիքիպեդիայում, [mixin](https://en.wikipedia.org/wiki/Mixin)-ը class է, որը պարունակում է մեթոդներ, որոնք կարող են օգտագործվել այլ class-ների կողմից՝ առանց դրանից ժառանգելու անհրաժեշտության։

Այլ կերպ ասած, *mixin*-ը տրամադրում է մեթոդներ, որոնք իրականացնում են որոշակի վարքագիծ, բայց մենք այն չենք օգտագործում որպես այդպիսին, այլ օգտագործում ենք դա՝ իր վարքագիծը այլ class-ներում ավելացնելու համար։

## Խառնուրդի օրինակ

JavaScript-ում խառնուրդիի ներդրման ամենապարզ ձևը օգտակար մեթոդներով օբյեկտ պատրաստելն է, որպեսզի հեշտությամբ կարողանանք դրանք միավորել ցանկացած class-ի նախատիպի մեջ:

Օրինակի համար, այստեղ `sayHiMixin` խառնուրդիը օգտագործվում է `User`-ի համար ինչ-որ «խոսք» ավելացնելու նպատակով.

```js run
*!*
// խառնուրդ
*/!*
let sayHiMixin = {
  sayHi() {
    alert(`Ողջույն ${this.name}`);
  },
  sayBye() {
    alert(`Ցտեսություն ${this.name}`);
  }
};

*!*
// Կիրառություն․
*/!*
class User {
  constructor(name) {
    this.name = name;
  }
}

// մեթոդների պատճենում
Object.assign(User.prototype, sayHiMixin);

// այժմ User-ը կարող է ասել ողջույն
new User("Dude").sayHi(); // Ողջույն Dude
```

There's no inheritance, but a simple method copying. So `User` may inherit from another class and also include the mixin to "mix-in" the additional methods, like this:
Չկա ժառանգություն, բայց կա պատճենահանման պարզ մեթոդ: Այսպիսով, `User`-ը կարող է ժառանգել մեկ այլ class-ից, ինչպես նաև ներառել խառնուրդը՝ լրացուցիչ մեթոդները «խառնելու» համար, այսպես.

```js
class User extends Person {
  // ...
}

Object.assign(User.prototype, sayHiMixin);
```

Խառնուրդները կարող են օգտվել ժառանգությունից իրենց ներսում:

Օրինակ՝ այստեղ `sayHiMixin`-ը ժառանգում է `sayMixin`-ից․

```js run
let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};

let sayHiMixin = {
  __proto__: sayMixin, // (կամ այստեղ նախատիպը տեղադրելու համար կարող ենք օգտագործել Object.setPrototypeOf)

  sayHi() {
    *!*
    // կանչում ենք ծնողի մեթոդը
    */!*
    super.say(`Ողջույն ${this.name}`); // (*)
  },
  sayBye() {
    super.say(`Ցտեսություն ${this.name}`); // (*)
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// պատճենում ենք մեթոդները
Object.assign(User.prototype, sayHiMixin);

// այժմ User-ը կարող է ասել ողջույն
new User("Dude").sayHi(); // Ողջույն Dude
```

Նկատի ունեցեք, որ `super.say()`-ից `super.say()` ծնող մեթոդի կանչը (`(*)` պիտակավորված տողերում) որոնում է մեթոդը այդ խառնուրդի նախատիպում, այլ ոչ թե class-ի նախատիպում:

Ահա գծապատկերը (տեսեք աջ մասը).

![](mixin-inheritance.svg)

Դա պայմանավորված է նրանով, որ `sayHi` և `sayBye` մեթոդներն ի սկզբանե ստեղծվել են `sayHiMixin`-ում: Այսպիսով, չնայած դրանք պատճենվել են, բայց դրանց `[[HomeObject]]` ներքին հատկությունը հղում է անում `sayHiMixin`-ին, ինչպես ցուցադրված է վերևի նկարում:

Քանի որ `super`-ը `[[HomeObject]].[[Prototype]]`-ում փնտրում է ծնողի մեթոդները, ապա դա նշանակում է, որ այն փնտրում է `sayHiMixin.[[Prototype]]`-ում, այլ ոչ թե `User.[[Prototype]]`-ում:

## EventMixin

Հիմա եկեք խառնուրդ պատրաստենք իրական կյանքի համար:

Բրաուզերի մի շարք օբյեկտների (օրինակ) կարևոր առանձնահատկությունն այն է, որ դրանք կարող են առաջացնել իրադարձություններ: Իրադարձությունները հիանալի միջոց են «տեղեկատվություն հեռարձակելու» բոլոր ցանկացողներին: Այսպիսով, եկեք ստեղծենք խառնուրդ, որը թույլ է տալիս մեզ հեշտությամբ ավելացնել իրադարձությունների հետ կապված ֆունկցիաներ ցանկացած class/object-ում:

- Միքսինը կտրամադրի `.trigger(name, [...data])` մեթոդ՝ «իրադարձություն առաջացնելու» համար, երբ դրա հետ որևէ կարևոր բան է պատահում: `name` արգումենտը իրադարձության անվանումն է, որին կամայականորեն հաջորդում են լրացուցիչ արգումենտներ՝ իրադարձության տվյալներով:
- Նաև `.on(name, handler)` մեթոդը, որն ավելացնում է `handler` ֆունկցիան որպես ունկնդիր տվյալ անունով իրադարձությունների համար: Այն կկանչվի, երբ գործարկվի տրված `name` ունեցող իրադարձությունը և կստանա արգումենտներ `.trigger` կանչից:
- ...Եվ `.off(name, handler)` մեթոդը, որը հեռացնում է `handler` ունկնդրին:

Խառնուրդ ավելացնելուց հետո `user` օբյեկտը կկարողանա ստեղծել `«login»` իրադարձություն, երբ այցելուն մուտք է գործում: Եվ մեկ այլ օբյեկտին, ասենք՝ `calendar`-ին, կարող է պետք լինի ունկնդրել նման իրադարձությունները՝ մուտք գործած անձանց համար օրացույցը բեռնելու նպատակով:

Կամ, `menu`-ն կարող է ստեղծել `«select»` իրադարձությունը, երբ ընտրվում է ընտրացանկի տարրը, և այլ օբյեկտները կարող են նշանակել մշակողների՝ արձագանքելու այդ իրադարձությանը: Եվ այսպես շարունակ։

Ահա կոդը.

```js run
let eventMixin = {
  /**
   * Բաժանորդագրվում ենք իրադարձությանը, կիրառություն.
   *  menu.on('select', function(item) { ... }
  */
  on(eventName, handler) {
    if (!this._eventHandlers) this._eventHandlers = {};
    if (!this._eventHandlers[eventName]) {
      this._eventHandlers[eventName] = [];
    }
    this._eventHandlers[eventName].push(handler);
  },

  /**
   * Չեղարկում ենք բաժանորդագրությունը, կիրառություն․
   *  menu.off('select', handler)
   */
  off(eventName, handler) {
    let handlers = this._eventHandlers?.[eventName];
    if (!handlers) return;
    for (let i = 0; i < handlers.length; i++) {
      if (handlers[i] === handler) {
        handlers.splice(i--, 1);
      }
    }
  },

  /**
   * Ստեղծում ենք իրադարձություն տրված անվանումով և տվյալներով
   *  this.trigger('select', data1, data2);
   */
  trigger(eventName, ...args) {
    if (!this._eventHandlers?.[eventName]) {
      return; // այդ անվանումով իրադարձության համար մշակողներ չկան
    }

    // կանչում ենք մշակողներին
    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
  }
};
```


- `.on(eventName, handler)`՝ վերագրում է `handler` ֆունկցիան, որը պետք է գործարկվի, երբ տեղի է ունենում այդ անվանումով իրադարձությունը: Տեխնիկապես կա `_eventHandlers` հատկություն, որը պահում է մշակողների զանգված յուրաքանչյուր իրադարձության անվան համար և պարզապես դա ավելացնում է ցանկին:
- `.off(eventName, handler)`՝ հեռացնում է ֆունկցիան մշակողների ցանկից:
- `.trigger(eventName, ...args)`՝ ստեղծում է իրադարձություն․ բոլոր մշակողները `_eventHandlers[eventName]`-ից կանչվում են `...args` արգումենտների ցանկով `...args`։

Կիրառություն․

```js run
// Ստեղծում ենք class
class Menu {
  choose(value) {
    this.trigger("select", value);
  }
}
// Ավելացնում ենք խառնուրդ՝ իրադարձության հետ կապված մեթոդներով
Object.assign(Menu.prototype, eventMixin);

let menu = new Menu();

// ավելացնում ենք մշակող, որը պետք է կանչվի ընտրության ժամանակ.
*!*
menu.on("select", value => alert(`Ընտրված արժեքը՝ ${value}`));
*/!*

// գործարկվում է իրադարձությունը => վերին մշակիչը գործարկվում է և ցույց է տալիս.
// Ընտրված արժեքը՝ 123
menu.choose("123");
```

Այժմ, եթե մենք ցանկանում ենք, որ որևէ կոդ արձագանքի ընտրացանկի ընտրությանը, մենք կարող ենք ունկնդրել այն `menu.on(...)`-ով:

Եվ `eventMixin` խառնուրդը հեշտացնում է նման վարքագծի ավելացումը այնքան class-ներում, որքան մեզ անհրաժեշտ է՝ առանց ժառանգական շղթային միջամտելու:

## Ամփոփում

*Mixin (խառնուրդ)*՝ ընդհանուր օբյեկտի վրա հիմնված ծրագրավորման տերմին է՝ class, որը պարունակում է մեթոդներ այլ class-ների համար։

Որոշ այլ լեզուներ թույլ են տալիս բազմակի ժառանգություն: JavaScript-ը չի աջակցում բազմակի ժառանգությանը, սակայն խառնուրդները կարող են իրագործվել՝ պատճենելով մեթոդները նախատիպի մեջ:

Որպես class-ը մեծացնելու միջոց կարող ենք օգտագործել խառնուրդները՝ ավելացնելով բազմաթիվ վարքագծեր, օրինակ՝ իրադարձությունների մշակումը, ինչպես տեսանք վերևում:

Խառնուրդները կարող են դառնալ հակասությունների աղբյուր, եթե դրանք պատահաբար վերագրեն առկա class-ի մեթոդները: Այսպիսով, ընդհանուր առմամբ, պետք է լավ մտածել խառնուրդի մեթոդներին անվանում տալուց առաջ, որպեսզի նվազագույնի հասցվի կոնֆլիկտների հավանականությունը:
