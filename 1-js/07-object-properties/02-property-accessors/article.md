
# Հատկության ստացողներ (getters) և տեղադրողներ (setters)

Գոյություն ունեն օբյեկտի երկու տեսակի հատկություններ:

Առաջինը *տվյալային հատկություններ* (data properties) տեսակն է: Մենք արդեն գիտենք, թե ինչպես աշխատենք դրանց հետ: Բոլոր հատկությունները, որոնք մինչև հիմա օգտագործում էինք, տվյալային հատկություններ էին:

Հատկության երկրորդ տեսակը մի նոր բան է: Դա *մուտքային հատկություն* (accessor property) է. Դրանք ըստ իրենց էության ֆունկցիաներ են, որոնք կատարվում են արժեքի ստացման և տեղադրման ժամանակ, բայց արտաքին կոդից սովորական հատկությունների տեսք ունեն:

## Գեթթերներ և սեթթերներ

Մուտքային հատկությունները ներկայացված են «գեթթեր» (ստացող) և «սեթթեր» (տեղադրող) մեթոդներով: Օբյեկտում բառացիորեն դրանք նշվում են որպես `get` և `set`.

```js
let obj = {
  *!*get propName()*/!* {
    // գեթթեր, կոդը կատարվում է obj.propName ստացման ժամանակ
  },

  *!*set propName(value)*/!* {
    // սեթթեր, կոդը կատարվում է obj.propName = value տեղադրման ժամանակ
  }
};
```

Գեթթերն աշխատում է, երբ `obj.propName`-ն ընթերցվում է, իսկ սեթթերը՝ երբ նշանակվում է:

Օրինակի համար, մենք ունենք `user` օբյեկտ՝ `name` և `surname` հատկություններով.

```js
let user = {
  name: "John",
  surname: "Smith"
};
```

Այժմ ցանկանում ենք ավելացնել `fullName` հատկությունը, որը պետք է լինի `«John Smith»`: Իհարկե, մենք չենք ցանկանում կլոնավորել առկա ինֆորմացիան, այնպես որ կարող ենք իրագործել այն որպես մուտքային մեթոդ․

```js run
let user = {
  name: "John",
  surname: "Smith",

*!*
  get fullName() {
    return `${this.name} ${this.surname}`;
  }
*/!*
};

*!*
alert(user.fullName); // John Smith
*/!*
```

Մուտքային հատկությունն արտաքինից սովորական հատկության տեսք ունի: Դա է մուտքային հատկությունների գաղափարը: Մենք չենք *կանչում* `user.fullName`-ը որպես ֆունկցիա, այլ *ընթերցում* ենք այն սովորականի պես. գեթթերն աշխատում է «կուլիսների ետևում»:

Այս պահին `fullName`-ն ունի միայն գեթթեր: Եթե փորձենք արժեվորել `user.fullName=`, ապա տեղի կունենա սխալ․

```js run
let user = {
  get fullName() {
    return `...`;
  }
};

*!*
user.fullName = "Թեստ"; // Սխալ (հատկությունն ունի միայն գեթթեր)
*/!*
```

Եկեք շտկենք դա՝ ավելացնելով սեթթեր `user.fullName`-ի համար.

```js run
let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

*!*
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
*/!*
};

// set fullName կատարվում է տրված արժեքով
user.fullName = "Գասպար Գալենտերյան";

alert(user.name); // Գասպար
alert(user.surname); // Գալենտերյան
```

Արդյունքում մենք ունենք «վիրտուալ» հատկություն `fullName`: Այն հասանելի է ընթերցելու և արժեվորելու համար:

## Մուտքային տվյալների նկարագրիչներ

Մուտքային հատկությունների նկարագրիչները տարբերվում են տվյալային հատկությունների նկարագրիչներից:

Մուտքային հատկությունների համար չկա `value` կամ `writable`, բայց փոխարենը կան `get` և `set` ֆունկցիաներ:

Այսինքն, մուտքային հատկությունների նկարագրիչը կարող է ունենալ.

- **`get`** -- առանց արգումենտների ֆունկցիա, որն աշխատում է հատկության ընթերցման ժամանակ,
- **`set`** -- մեկ արգումենտով ֆունկցիա, որը կանչվում է հատկության արժեվորման ժամանակ,
- **`enumerable`** -- նույնը, ինչ տվյալային հատկությունների համար,
- **`configurable`** -- նույնը, ինչ տվյալային հատկությունների համար:

Օրինակի համար, `defineProperty`-ով `fullName` մուտքային հատկություն ստեղծելու համար, մենք կարող ենք փոխանցել նկարագրիչը `get`-ով և `set`-ով.

```js run
let user = {
  name: "John",
  surname: "Smith"
};

*!*
Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
*/!*
});

alert(user.fullName); // John Smith

for(let key in user) alert(key); // name, surname
```

Նկատի ունեցեք, որ հատկությունը կարող է լինել մուտքային (ունի `get/set` մեթոդներ) կամ տվյալային (ունի `value`), բայց ոչ՝ երկուսն էլ միաժամանակ:

Եթե փորձենք կիրառել երկուսն էլ՝ `get` և `value` միևնույն նկարագրիչում, ապա տեղի կունենա սխալ.

```js run
*!*
// Error: Invalid property descriptor.
*/!*
Object.defineProperty({}, 'prop', {
  get() {
    return 1
  },

  value: 2
});
```

## Խելացի գեթթերներ և սեթթերներ

Գեթթերներն ու սեթթերները կարող են օգտագործվել որպես հատկության «իրական» արժեքների փաթաթաններ, ավելի շատ հսկողություն ձեռք բերելու համար նրանց հետ գործողությունների ժամանակ:

Օրինակի համար, եթե ցանկանում ենք արգելել շատ կարճ անունները `user`-ի համար, մենք կարող ենք ունենալ `name` սեթթեր և պահել արժեքը առանձին հատկությունով՝ `_name`․

```js run
let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      alert("Անունը շատ կարճ է, պետք է լինի նվազագույնը 4 նիշ");
      return;
    }
    this._name = value;
  }
};

user.name = "Պողոս";
alert(user.name); // Պողոս

user.name = ""; // Անունը շատ կարճ է...
```

Այսպիսով, անունը պահվում է `_name` հատկության մեջ, իսկ հասանելիությունը լինում է գեթթերի և սեթթերի միջոցով:

Տեխնիկապես արտաքին կոդը ի վիճակի է ուղղակիորեն մուտք ունենալ անվանը՝ օգտագործելով `user._name`: Բայց, գոյություն ունի լայնորեն հայտնի կոնվենցիա, որ ներքևի գծով `«_»` սկսվող հատկությունները համարվում են ներքին և պետք է անձեռնմխելի լինեն օբյեկտից դուրս:


## Համատեղելիության համար օգտագործում

Մուտքային հատկությունների մեծ կիրառություններից մեկն այն է, որ դրանք թույլ են տալիս ցանկացած պահի վերահսկել «սովորական» տվյալային հատկությունը՝ փոխարինելով այն գեթթերով և սեթթերով, և կարգավորել պահելաձևը:

Պատկերացրեք, որ մենք սկսել ենք ներդնել օգտվողի օբյեկտներ՝ օգտագործելով տվյալային `name` և `age` հատկությունները.

```js
function User(name, age) {
  this.name = name;
  this.age = age;
}

let john = new User("John", 25);

alert( john.age ); // 25
```

...բայց վաղ թե ուշ, կարող է բան փոխվել և `age`-ի փոխարեն մենք միգուցե որոշենք `birthday`-ը պահել, որովհետև դա ավելի ճշգրիտ է և հարմար.

```js
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}

let john = new User("John", new Date(1992, 6, 1));
```

Հիմա ի՞նչ անել հին կոդի հետ, որը դեռ օգտագործում է `age` հատկությունը:

Մենք կարող ենք փորձել գտնել բոլոր նմանատիպ հատվածները և շտկել դրանք, բայց դա ժամանակ է պահանջում և կարող է դժվար լինել, եթե այդ կոդը օգտագործվում է շատ այլ մարդկանց կողմից: Եվ բացի այդ, `age`-ը լավ բան է `user`-ում ունենալու համար, այդպես չէ՞:

Եկեք պահենք այն:

Գեթթերի ավելացումը `age`-ի համար կլուծի խնդիրը.

```js run no-beautify
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

*!*
  // տարիքը հաշվարկվում է ընթացիկ ամսաթվից և ծննդյան օրվանից կախված
  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
*/!*
}

let john = new User("John", new Date(1992, 6, 1));

alert( john.birthday ); // ծննդյան օրը հասանելի է
alert( john.age );      // ...ինչպես նաև տարիքը
```

Այժմ հին կոդը նույնպես աշխատում է, և մենք ունենք լրացուցիչ լավ հատկություն:
