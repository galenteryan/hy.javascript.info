# Հարազատ նախատիպեր

Այս `«prototype»` հատկությունը լայնորեն օգտագործվում է հենց JavaScript-ի միջուկի կողմից: Բոլոր ներկառուցված կոնստրուկտոր ֆունկցիաներն օգտագործում են այն:

First we'll see at the details, and then how to use it for adding new capabilities to built-in objects.
Սկզբում մենք կդիտարկենք մանրամասները, իսկ հետո՝ ինչպես օգտագործել այն ներկառուցված օբյեկտներին նոր հնարավորություններ ավելացնելու համար:

## Object.prototype

Ենթադրենք, մենք դատարկ օբյեկտ ենք արտատպում.

```js run
let obj = {};
alert( obj ); // "[object Object]" ?
```

Որտե՞ղ է `«[object Object]»` տողը ստեղծող կոդը: Սա ներկառուցված `toString` մեթոդ է, բայց որտե՞ղ է այն, `obj`-ն դատարկ է․․․

...Սակայն `obj = {}` հակիրճ նշումը նույնն է, ինչ `obj = new Object()`, որտեղ `Object`-ը ներկառուցված օբյեկտի կոնստրուկտոր ֆունկցիա է՝ իր սեփական `prototype`-ով, որը հղում է անում հսկայական օբյեկտին՝ իր `toString` և այլ մեթոդներով:

Ահա թե ինչ է կատարվում.

![](object-prototype.svg)

Երբ `new Object()` է կանչվում (կամ բառացիորեն ստեղծվում է օբյեկտ՝ `{...}`, դրա `[[Prototype]]`-ը լինում է `Object.prototype`՝ համաձայն նախորդ գլխում մեր քննարկած կանոնի:

![](object-prototype-1.svg)

Այսպիսով, երբ `obj.toString()` է կանչվում, մեթոդը վերցվում է `Object.prototype`-ից:

Մենք կարող ենք ստուգել այն այսպես.

```js run
let obj = {};

alert(obj.__proto__ === Object.prototype); // true

alert(obj.toString === obj.__proto__.toString); //true
alert(obj.toString === Object.prototype.toString); //true
```

Նկատի ունեցեք, որ `Object.prototype`-ի վերին շղթայում այլևս չկա `[[Prototype]]`․

```js run
alert(Object.prototype.__proto__); // null
```

## Այլ ներկառուցված նախատիպեր

Այլ ներկառուցված օբյեկտներ, ինչպիսիք են `Array`, `Date`, `Function` և այլն, նույնպես պահում են մեթոդները նախատիպերում:

Օրինակ՝ երբ մենք ստեղծում ենք `[1, 2, 3]` զանգված, ապա ներսից օգտագործվում է կանխադրված `new Array()` կոնստրուկտորը: Այսպիսով, `Array.prototype`-ը դառնում է դրա նախատիպը և տրամադրում է մեթոդներ: Դա շատ արդյունավետ է հիշողության օգտագործման համար:

Ըստ հատկորոշման, բոլոր ներկառուցված նախատիպերն ունեն `Object.prototype` վերևում: Դրա համար ոմանք ասում են, որ «ամեն ինչ ժառանգվում է օբյեկտներից»։

Ահա ընդհանուր պատկերը (3 ներկառուցված օբյեկտների համար).

![](native-prototypes-classes.svg)

Եկեք ստուգենք նախատիպերը.

```js run
let arr = [1, 2, 3];

// արդյո՞ք այն ժառանգում է Array.prototype-ից
alert( arr.__proto__ === Array.prototype ); // true

// այնուհետև ստուգենք՝ Object.prototype-ի՞ց
alert( arr.__proto__.__proto__ === Object.prototype ); // true

// և null ամենավերևում
alert( arr.__proto__.__proto__.__proto__ ); // null
```

Նախատիպերի որոշ մեթոդներ կարող են համընկնել, օրինակ՝ `Array.prototype`-ն ունի իր սեփական `toString`-ը, որը թվարկում է տարրերը՝ սահմանազատված ստորակետերով.

```js run
let arr = [1, 2, 3]
alert(arr); // 1,2,3 <-- Array.prototype.toString-ի արդյունքը
```

Ինչպես նախկինում տեսանք, `Object.prototype`-ը նույնպես ունի `toString`, բայց `Array.prototype`-ը շղթայում ավելի մոտ է, ուստի զանգվածի տարբերակն է օգտագործվում:


![](native-prototypes-array-tostring.svg)


Բրաուզերի գործիքները, ինչպիսին է Chrome-ի developer console-ը և այլն, ժառանգականությունը նույնպես ցուցադրում են (ներկառուցված օբյեկտների համար կարող է պետք լինի օգտագործել `console.dir`-ը).

![](console_dir_array.png)

Այլ ներկառուցված օբյեկտները նույնպես աշխատում են նույն կերպ: Նույնիսկ ֆունկցիաները. դրանք ներկառուցված `Function` կոնստրուկտորի օբյեկտներ են, և դրանց մեթոդները (`call`/`apply` և այլն) վերցված են `Function.prototype`-ից: Ֆունկցիաները նույնպես ունեն իրենց սեփական `toString`-ը:

```js run
function f() {}

alert(f.__proto__ == Function.prototype); // true
alert(f.__proto__.__proto__ == Object.prototype); // true, ժառանգում է օբյեկտից
```

## Պրիմիտիվներ

Ամենաբարդ բանը տեղի է ունենում տողերի, թվերի և բուլյանների հետ:

Ինչպես հիշում ենք, դրանք օբյեկտներ չեն։ Բայց եթե փորձենք մուտք գործել դեպի դրանց հատկություններ, ապա ներկառուցված `String`, `Number` և `Boolean` կոնստրուկտորների միջոցով կստեղծվեն ժամանակավոր օբյեկտ-կաղապարներ: Տրամադրում են մեթոդներն ու անհետանում։

Այս օբյեկտները ստեղծվում են մեզ համար անտեսանելի կերպով, իսկ շարժիչների մեծ մասն օպտիմիզացնում են դրանք, բայց տեխնիկական հատկորոշիչները դա նկարագրում են հենց այսպես․ այս օբյեկտների մեթոդները նաև նախատիպերում են գտնվում, որոնք հասանելի են որպես `String.prototype`, `Number.prototype` և `Boolean.prototype`:

```warn header="`null` և `undefined` արժեքները չունեն կաղապար-օբյեկտներ"
Այս հատուկ արժեքները՝ `null` և `undefined`, առանձնանում են: Դրանք չունեն օբյեկտ-կաղապարներ, ուստի դրանց համար չկան մեթոդներ և հատկություններ: Չկան նաև համապատասխան նախատիպեր։
```

## Հարազատ նախատիպերի փոփոխություն [#native-prototype-change]

Հարազատ նախատիպերը կարող են փոփոխվել: Օրինակի համար, եթե մենք մեթոդ ավելացնենք `String.prototype`-ին, այն հասանելի է դառնում բոլոր տողերի (string) համար.

```js run
String.prototype.show = function() {
  alert(this);
};

"BOOM!".show(); // BOOM!
```

Ծրագրավորման ընթացքում մեզ մոտ կարող է միտք ձևավորվել նոր ներկառուցված մեթոդների հետ կապված, որոնք կցանկանայինք ունենալ, և մեզ մոտ կարող է գայթակղություն առաջանալ՝ ավելացնել դրանք հարազատ նախատիպերում: Բայց դա ընդհանուր առմամբ վատ գաղափար է:

```warn
Նախատիպերը գլոբալ են, ուստի հեշտությամբ կարող է կոնֆլիկտ առաջանալ: Եթե երկու գրադարան ավելացնեն `String.prototype.show` մեթոդը, ապա դրանցից մեկը կվերագրի մյուսի մեթոդը:

Այսպիսով, ընդհանուր առմամբ, հարազատ նախատիպի փոփոխումը վատ գաղափար է համարվում:
```

**Ժամանակակից ծրագրավորման մեջ կա միայն մի դեպք, երբ արդարացվում է հարազատ նախատիպերի փոփոխումը։ Դա պոլիֆիլինգն (polyfilling) է։**

Պոլիֆիլինգը տերմին է, որը կարող է փոխարինել մի մեթոդի, որը գոյություն ունի JavaScript-ի հատկորոշման մեջ, բայց դեռ չի սպասարկվում այս կամ այն JavaScript շարժիչի կողմից:

Այնուհետև մենք կարող ենք դա իրագործել և դրանով համալրել ներկառուցված նախատիպը:

Օրինակ․

```js run
if (!String.prototype.repeat) { // եթե այդպիսի մեթոդ չկա
  // ավելացնել այն նախատիպում

  String.prototype.repeat = function(n) {
    // կրկնել տողը n անգամ

    // իրականում կոդը պետք է լինի մի փոքր ավելի բարդ, քան սա
    // (ամբողջական ալգորիթմը նշված է հատկորոշման մեջ)
    // բայց նույնիսկ անկատար պոլիֆիլը հաճախ բավականին լավ է համարվում
    return new Array(n + 1).join(this);
  };
}

alert( "Լա".repeat(3) ); // ԼաԼաԼա
```


## Փոխառություն նախատիպերից

<info:call-apply-decorators#method-borrowing> գլխում մենք խոսեցինք փոխառության մեթոդի մասին:

Դա այն է, երբ մենք մեթոդ ենք վերցնում մի օբյեկտից և պատճենում այն մյուսի մեջ:

Հարազատ նախատիպերի որոշ մեթոդներ հաճախ փոխառվում են:

Օրինակի համար, եթե մենք զանգվածին նման (array-like) օբյեկտ ենք ստեղծում, մենք կարող է ցանկանանք պատճենել դրա մեջ `Array`-ի որոշ մեթոդներ:

Օրինակ․

```js run
let obj = {
  0: "Hello",
  1: "world!",
  length: 2,
};

*!*
obj.join = Array.prototype.join;
*/!*

alert( obj.join(',') ); // Hello,world!
```

Այն աշխատում է, քանի որ ներկառուցված `join` մեթոդի ալգորիթմը հոգ է տանում միայն ճշգրիտ ինդեքսների և `length` հատկության մասին: Այն չի ստուգում՝ օբյեկտն իսկապես զանգված է, թե ոչ: Շատ ներկառուցված մեթոդներ նման կերպով են աշխատում:

Մեկ այլ հնարավորություն է ժառանգել՝ `obj.__proto__`-ն տեղադրելով `Array.prototype`-ում, որպեսզի `Array`-ի բոլոր մեթոդները ավտոմատ կերպով հասանելի լինեն `obj`-ում:

Բայց դա անհնար է, եթե `obj`-ն արդեն ժառանգում է մեկ այլ օբյեկտից: Հիշեք, որ մենք միաժամանակ կարող ենք ժառանգել միայն մեկ օբյեկտից:

Փոխառության մեթոդները ճկուն են, դա թույլ է տալիս անհրաժեշտության դեպքում խառնել տարբեր օբյեկտների ֆունկցիոնալությունը:

## Ամփոփում

- Բոլոր ներկառուցված օբյեկտները հետևում են նույն օրինաչափությանը.
    - Մեթոդները պահվում են նախատիպում (`Array.prototype`, `Object.prototype`, `Date.prototype` և այլն)։
    - Օբյեկտն ինքնին պահում է միայն տվյալները (զանգվածի տարրեր, օբյեկտի հատկություններ, ամսաթիվը)։
- Պրիմիտիվները պահում են մեթոդները նաև կաղապարային օբյեկտների նախատիպերում՝ `Number.prototype`, `String.prototype` և `Boolean.prototype`: Միայն `undefined`-ը և `null`-ը չունեն կաղապարային օբյեկտներ:
- Ներկառուցված նախատիպերը կարող են փոփոխվել կամ համալրվել նոր մեթոդներով: Բայց խորհուրդ չի տրվում փոփոխել դրանք: Միակ թույլատրելի դեպքը հավանաբար այն է, երբ մենք ավելացնում ենք նոր ստանդարտ, բայց այն դեռ չի սպասարկվում JavaScript շարժիչի կողմից:
