
# Նախատիպի մեթոդներ, օբյեկտներ առանց __proto__

Այս բաժնի առաջին գլխում մենք նշեցինք, որ կան նախատիպի կարգավորման ժամանակակից մեթոդներ:

`__proto__`-ն որոշ չափով համարվում է հնացած (սպասարկվում է JavaScript ստանդարտի միայն բրաուզերային հատվածում):

Ժամանակակից մեթոդներն են.

- [Object.create(proto, [descriptors])](mdn:js/Object/create)՝ տրված `proto`-ով ստեղծում է դատարկ օբյեկտ՝ որպես `[[Prototype]]` և կամընտիր հատկությունների նկարագրիչներ:
- [Object.getPrototypeOf(obj)](mdn:js/Object/getPrototypeOf)՝ վերադարձնում է `obj`-ի `[[Prototype]]`-ը։
- [Object.setPrototypeOf(obj, proto)](mdn:js/Object/setPrototypeOf)՝ տեղադրում է `obj`-ի `[[Prototype]]`-ը որպես `proto`։

Սրանք պետք է օգտագործվեն `__proto__`-ի փոխարեն:

Օրինակ․

```js run
let animal = {
  eats: true
};

// ստեղծել նոր օբյեկտ, որի նախատիպը animal-ն է
*!*
let rabbit = Object.create(animal);
*/!*

alert(rabbit.eats); // true

*!*
alert(Object.getPrototypeOf(rabbit) === animal); // true
*/!*

*!*
Object.setPrototypeOf(rabbit, {}); // rabbit-ի նախատիպը փոփոխել {}-ի
*/!*
```

`Object.create`-ն ունի կամընտիր երկրորդ արգումենտ՝ հատկության նկարագրիչներ, որտեղ մենք կարող ենք լրացուցիչ հատկություններ տրամադրել նոր օբյեկտին հետևյալ եղանակով.

```js run
let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});

alert(rabbit.jumps); // true
```

Նկարագրիչները նույն ձևաչափով են, ինչպես նկարագրված է <info:property-descriptors> գլխում:

We can use `Object.create` to perform an object cloning more powerful than copying properties in `for..in`:
Մենք կարող ենք օգտագործել `Object.create`՝ օբյեկտի կլոնավորումն ավելի հզոր ձևով իրականացնելու համար, քան `for..in`-ով հատկություններ պատճենելն է․

```js
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
```

Այս կանչը ստեղծում է `obj`-ի համար իսկապես ճշգրիտ պատճեն՝ ներառյալ բոլոր հատկությունները. թվարկելի և անթվարկելի հատկությունները, տվյալային հատկություններն ու սեթթերներ/գեթթերները՝ ամեն ինչ, ու ճշգրիտ `[[Prototype]]`-ով:

## Համառոտ պատմություն

Եթե հաշվենք `[[Prototype]]`-ը կառավարելու բոլոր եղանակները՝ դրանք շատ են: Նույն բանն անելու համար բազմաթիվ եղանակներ կան:

Ինչո՞ւ։

Պատմական պատճառներով է այդպես։

- Կոնստրուկտոր ֆունկցիայի `«prototype»` հատկությունը գործել է շատ հին ժամանակներից:
- Ավելի ուշ՝ 2012 թվականին, ստանդարտում հայտնվեց `Object.create`-ը: Այն նշված նախատիպով օբյեկտներ ստեղծելու հնարավորություն էր տալիս, սակայն ստանալու/տեղադրելու հնարավորություն չէր տալիս։ Այսպիսով, բրաուզերները ներդրեցին ոչ ստանդարտ `__proto__` մուտքայինը (accessor), որն օգտվողին թույլ էր տալիս ցանկացած պահի ստանալ/տեղադրել նախատիպ:
- Ավելի ուշ՝ 2015 թվականին, ստանդարտում ավելացվեցին `Object.setPrototypeOf`-ը և `Object.getPrototypeOf`-ը, որպեսզի կատարեն նույն գործառույթը, ինչ `__proto__`-ն է կատարում: Քանի որ `__proto__`-ն դե-ֆակտո ներդրվել էր ամենուր և այն մի տեսակ հնացած էր, իր ճանապարհը անցավ ստանդարտի Annex B, այսինքն՝ կամընտիր դարձավ ոչ բրաուզերային միջավայրերի համար:

Այս պահի դրությամբ մեր տրամադրության տակ են այս բոլոր տարբերակները։

Ինչո՞ւ `__proto__`-ն փոխարինվեց `getPrototypeOf/setPrototypeOf` ֆունկցիաներով: Սա հետաքրքիր հարց է, որը պահանջում է հասկանալ, թե ինչու է `__proto__`-ն վատ: Պատասխանը ստանալու համար շարունակեք ընթերցել։

```warn header="Մի փոխեք գոյություն ունեցող օբյեկտների `[[Prototype]]`-ը, եթե արագությունը կարևոր է"
Տեխնիկապես մենք կարող ենք ցանկացած պահի ստանալ/տեղադրել `[[Prototype]]`։ Բայց սովորաբար մենք այն տեղադրում ենք միայն մեկ անգամ օբյեկտի ստեղծման ժամանակ և այլևս չենք փոփոխում. `rabbit`-ը ժառանգում է `animal`-ից և դա չենք փոխում:

Նաև JavaScript-ի շարժիչներն են դրա համար շատ օպտիմիզացված: նախատիպը «ոտքի վրա» փոխելը `Object.setPrototypeOf`-ի կամ `obj.__proto__=`-ի միջոցով շատ դանդաղ գործընթաց է, քանի որ խախտում է օբյեկտների հատկության հասանելիության գործառնությունների ներքին օպտիմիզացումը: Այսպիսով, խուսափեք դրանից, քանի դեռ չգիտեք, թե ինչ եք անում, կամ, եթե JavaScript-ի արագությունը բացարձակապես կարևոր չէ Ձեզ համար:
```

## «Շատ պարզ» օբյեկտներ [#very-plain]

Ինչպես գիտենք, օբյեկտները կարող են օգտագործվել որպես ասոցիատիվ զանգվածներ՝ բանալի-արժեք զույգեր պահելու համար։

...Բայց եթե մենք փորձենք դրանում պահել *օգտագործողի կողմից տրամադրված* բանալիներ (օրինակ՝ օգտագործողի կողմից մուտքագրված բառարան), ապա կարող ենք տեսնել մի հետաքրքիր անսարքություն. բոլոր բանալիները լավ են աշխատում, բացառությամբ `«__proto__»`-ից:

Դիտեք օրինակը.

```js run
let obj = {};

let key = prompt("Ո՞րն է բանալին։", "__proto__");
obj[key] = "ինչ-որ արժեք";

alert(obj[key]); // [object Object], այլ ոչ "ինչ-որ արժեք"!
```

Այստեղ, եթե օգտվողը մուտքագրում է `__proto__`, նշանակումն անտեսվում է:

Դա մեզ չպետք է զարմացնի: `__proto__` հատկությունը հատուկ է. այն պետք է լինի կամ օբյեկտ կամ `null`: Տողը (string) չի կարող նախատիպ դառնալ:

Բայց մենք *միտք չունեինք* իրականացնել նման սցենար, չէ՞։ Մենք ցանկանում ենք պահել բանալի-արժեք զույգեր, և `«__proto__»` անվանումով բանալին ճիշտ չի պահպանվել: Այսպիսով, դա վրիպակ է (bug):

Այստեղ հետևանքները սարսափելի չեն։ Բայց այլ դեպքերում մենք կարող ենք օբյեկտի տեսքով արժեքներ նշանակել, իսկ հետո նախատիպը իսկապես կարող է փոխվել: Արդյունքում, կատարումը սխալ կլինի՝ բոլորովին անսպասելի ձևերով:

Ի՞նչն է ավելի վատ. սովորաբար ծրագրավորողներն ընդհանրապես չեն մտածում նման հնարավորության մասին: Դա դժվարացնում է նմանատիպ սխալներ նկատելը և նույնիսկ դրանք վերածվում են խոցելիության, հատկապես, երբ JavaScript-ն օգտագործվում է սերվերի հատվածում:

Անսպասելի բաներ կարող են պատահել նաև `toString`-ին, որը լռելյայն ֆունկցիա է, և այլ ներկառուցված մեթոդներին վերագրելիս:

Ինչպե՞ս կարող ենք խուսափել այս խնդրից:

Նախ, մենք կարող ենք պարզապես անցնել `Map`-ի օգտագործմանը պահեստավորման համար՝ սովորական օբյեկտների փոխարեն, որից հետո ամեն ինչ կարգին կլինի:

Բայց `Object`-ը կարող է նաև մեզ լավ ծառայել այստեղ, քանի որ լեզվի ստեղծողները վաղուց են մտածել այդ խնդրի մասին:

`__proto__`-ն օբյեկտի հատկություն չէ, այլ `Object.prototype`-ի մուտքային հատկություն է.

![](object-prototype-2.svg)

Այսպիսով, եթե `obj.__proto__`-ն ընթերցվում կամ դրվում է, ապա դրա նախատիպից կանչվում է համապատասխան գեթթերը/սեթթերը, և այն ստանում/տեղադրում է `[[Prototype]]`:

Ինչպես ասվեց այս ձեռնարկի սկզբում. `__proto__`-ն `[[Prototype]]`-ին մուտք ունենալու միջոց է, դա ինքնին `[[Prototype]]` չէ:

Այժմ, եթե մենք մտադիր ենք օգտագործել օբյեկտը որպես ասոցիատիվ զանգված և զերծ մնալ նման խնդիրներից, կարող ենք դա անել մի փոքր հնարքով.

```js run
*!*
let obj = Object.create(null);
*/!*

let key = prompt("Ո՞րն է բանալին։", "__proto__");
obj[key] = "ինչ-որ արժեք";

alert(obj[key]); // "ինչ-որ արժեք"
```

`Object.create(null)`-ը ստեղծում է դատարկ օբյեկտ առանց նախատիպի (`[[Prototype]]`-ը `null` է):

![](object-prototype-null.svg)

Այսպիսով, `__proto__`-ի համար ժառանգական գեթթեր/սեթթեր չկա: Այժմ այն մշակվում է որպես սովորական տվյալային հատկություն, ուստի վերը նշված օրինակը ճիշտ է աշխատում:

Նման օբյեկտները կարող ենք անվանել «շատ պարզ» կամ «մաքուր բառարանով» օբյեկտներ, քանի որ դրանք նույնիսկ ավելի պարզ են, քան սովորական պարզ օբյեկտը՝ `{...}`:

Բացասական կողմն այն է, որ նման օբյեկտները չունեն որևէ ներկառուցված մեթոդներ, օրինակ՝ `toString`․

```js run
*!*
let obj = Object.create(null);
*/!*

alert(obj); // Error (չկա toString)
```

...Բայց դա սովորաբար լավ է ասոցիատիվ զանգվածների համար:

Նկատի ունեցեք, որ օբյեկտների հետ կապված մեթոդներից շատերը `Object.something(...)` են, ինչպես `Object.keys(obj)`-ն. դրանք նախատիպում չեն, ուստի կշարունակեն աշխատել նմանատիպ օբյեկտների համար.


```js run
let chineseDictionary = Object.create(null);
chineseDictionary.hello = "你好";
chineseDictionary.bye = "再见";

alert(Object.keys(chineseDictionary)); // hello,bye
```

## Ամփոփում

Նախատիպը կարգավորելու և դրանց ուղղակիորեն մուտք գործելու ժամանակակից մեթոդներն են.

- [Object.create(proto, [descriptors])](mdn:js/Object/create) -- ստեղծում է դատարկ օբյեկտ տրված `proto`-ով որպես `[[Prototype]]` (կարող է լինել `null`) և կամընտիր հատկությունների նկարագրիչներ:
- [Object.getPrototypeOf(obj)](mdn:js/Object/getPrototypeOf) -- վերադարձնում է `obj`-ի `[[Prototype]]`-ը (նույնն է, ինչ `__proto__`-ի գեթթերը):
- [Object.setPrototypeOf(obj, proto)](mdn:js/Object/setPrototypeOf) -- `obj`-ի `[[Prototype]]`-ը դնում է `proto` (նույնը, ինչ `proto`-ի սեթթերը):

Ներկառուցված `__proto__`-ի գեթթերը/սեթթերը անվտանգ չէ, եթե մենք ցանկանում ենք օբյեկտի մեջ տեղադրել օգտվողի կողմից ստեղծված բանալիներ: Պարզապես այն պատճառով, որ օգտատերը կարող է մուտքագրել `«__proto__»`՝ որպես բանալի, և սխալ կլինի, հուսանք՝ թեթև, բայց ընդհանուր առմամբ անկանխատեսելի հետևանքներով:

Այսպիսով, մենք կարող ենք կամ օգտագործել `Object.create(null)`՝ առանց `__proto__`-ի «շատ պարզ» օբյեկտ ստեղծելու համար, կամ օգտագործել `Map` օբյեկտներ:

Նաև, `Object.create`-ն ապահովում է օբյեկտի մակերեսային պատճենման հեշտ միջոց իր բոլոր նկարագրիչներով.

```js
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
```

Մենք նաև պարզ դարձրեցինք, որ `__proto__`-ն `[[Prototype]]`-ի գեթթեր/սեթթեր է և գտնվում է `Object.prototype`-ում, ինչպես մյուս մեթոդները:

Such objects are used as "pure dictionaries", they have no issues with `"__proto__"` as the key.
Մենք `Object.create(null)`-ով կարող ենք օբյեկտ ստեղծել առանց նախատիպի: Նման օբյեկտները օգտագործվում են որպես «մաքուր բառարաններ», դրանք `«__proto__»`-ի՝ որպես բանալիի հետ, խնդիրներ չունեն:

Այլ մեթոդներ.

- [Object.keys(obj)](mdn:js/Object/keys) / [Object.values(obj)](mdn:js/Object/values) / [Object.entries(obj)](mdn:js/Object/entries)՝ վերադարձնում է սեփական թվարկելի տողային հատկության անուններից/արժեքներից/բանալի-արժեք զույգերից բաղկացած զանգված:
- [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols)՝ վերադարձնում է բոլոր սեփական սիմվոլային բանալիների զանգվածը:
- [Object.getOwnPropertyNames(obj)](mdn:js/Object/getOwnPropertyNames)՝ վերադարձնում է բոլոր սեփական տողային բանալիների զանգվածը:
- [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys)՝ վերադարձնում է բոլոր սեփական բանալիների զանգվածը:
- [obj.hasOwnProperty(key)](mdn:js/Object/hasOwnProperty)՝ վերադարձնում է `true`, եթե `obj`-ն ունի իր սեփական (չժառանգված) բանալին՝ `key` անվանումով:

Բոլոր մեթոդները, որոնք վերադարձնում են օբյեկտի հատկությունները (օրինակ՝ `Object.keys`-ը և այլն), վերադարձնում են «սեփական» հատկություններ: Եթե պետք են նաև ժառանգականները, կարող ենք օգտագործել `for..in`-ը:
