Եկեք ուշադիր նայենք, թե ինչ է կատարվում `speedy.eat("խնձոր")` կանչի ժամանակ:

1. `speedy.eat` մեթոդը գտնվում է նախատիպում (`=hamster`), այնուհետև կատարվում է `this=speedy` (օբյեկտը կետից առաջ):

2. Այնուհետև `this.stomach.push()`-ը պետք է գտնի `stomach` հատկությունը և դրա համար կանչի `push`-ը: `this`-ում այն փնտրում է `stomach` (`=speedy`), բայց ոչինչ չի գտնում:

3. Այնուհետև այն հետևում է նախատիպային շղթային և `hamster`-ի մեջ է գտնում `stomach`-ը:

4. Այնուհետև կանչում է `push`-ը՝ ավելացնելով սնունդը *նախատիպի ստամոքսում*:

Այսպիսով, բոլոր համստերները կիսում են մեկ ստամոքս:

Եվ `lazy.stomach.push(...)`-ի և `speedy.stomach.push()`-ի համար, `stomach` հատկությունը գտնվում է նախատիպում (քանի որ այն բուն օբյեկտում չկա), հետևաբար նոր տվյալները ավելացվում են դրա մեջ:

Նկատի ունեցեք, որ նման բան չի լինում `this.stomach=`-ի պարզ նշանակման դեպքում.

```js run
let hamster = {
  stomach: [],

  eat(food) {
*!*
    // նշել this.stomach՝ this.stomach.push-ի փոխարեն
    this.stomach = [food];
*/!*
  }
};

let speedy = {
   __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// Speedy-ն գտավ սնունդը
speedy.eat("խնձոր");
alert( speedy.stomach ); // խնձոր

// Lazy-ի ստամոքսը դատարկ է
alert( lazy.stomach ); // <ոչինչ>
```

Այժմ ամեն ինչ ճշգրիտ է աշխատում, քանի որ `this.stomach=`-ը չի կատարում `stomach`-ի որոնում: Արժեքը ուղղակիորեն գրված է `this` օբյեկտի մեջ:

Նաև մենք կարող ենք լիովին խուսափել խնդրից՝ համոզվելով, որ յուրաքանչյուր համստեր ունի իր ստամոքսը.

```js run
let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster,
*!*
  stomach: []
*/!*
};

let lazy = {
  __proto__: hamster,
*!*
  stomach: []
*/!*
};

// Speedy-ն գտավ սնունդը
speedy.eat("խնձոր");
alert( speedy.stomach ); // խնձոր

// Lazy-ի ստամոքսը դատարկ է
alert( lazy.stomach ); // <ոչինչ>
```

Որպես ընդհանուր լուծում, բոլոր հատկությունները, որոնք նկարագրում են որոշակի օբյեկտի վիճակը, ինչպես վերը նշված `stomach`-ը, պետք է գրվեն այդ օբյեկտի մեջ: Դա կանխում է նմանատիպ խնդիրները։
