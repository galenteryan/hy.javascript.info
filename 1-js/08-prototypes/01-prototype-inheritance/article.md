# Նախատիպային ժառանգություն

Ծրագրավորման մեջ մենք հաճախ ցանկանում ենք ինչ-որ բան վերցնել և ընդլայնել այն:

Օրինակի համար, ունենք `user` օբյեկտ իր հատկություններով և մեթոդներով, նաև ցանկանում ենք `admin` և `guest` օբյեկտներ՝ որպես դրա մի փոքր փոփոխված տարբերակներ։ Մեզ անհրաժեշտ է նորից օգտագործել այն, ինչ ունենք `user`-ում, և պարզապես դրա վրա կառուցել նոր օբյեկտ, այլ ոչ թե պատճենել/վերաիրականացնել դրա մեթոդները:

*Նախատիպային ժառանգությունը* լեզվական հատկանիշ է, որն օգնում է դա անել:

## [[Prototype]]

JavaScript-ում օբյեկտներն ունեն հատուկ թաքնված հատկություն՝ `[[Prototype]]` (ինչպես նշված է հատկորոշման (specification) մեջ), որը կամ `null` է կամ հղում է կատարում մեկ այլ օբյեկտի։ Այդ օբյեկտը կոչվում է «նախատիպ»:

![prototype](object-prototype-empty.svg)

Երբ ընթերցում ենք որևէ հատկություն `object`-ից, իսկ այն բացակայում է, JavaScript-ն այն ավտոմատ կերպով վերցնում է նախատիպից: Ծրագրավորման մեջ դա կոչվում է «նախատիպային ժառանգություն»: Եվ շուտով մենք կուսումնասիրենք այդպիսի ժառանգության բազմաթիվ օրինակներ, ինչպես նաև դրա վրա կառուցված ավելի ընդլայնված լեզվական առանձնահատկություններ:

`[[Prototype]]`-ը ներքին և թաքնված հատկություն է, բայց այն սահմանելու համար կան բազմաթիվ եղանակներ:

Դրանցից մեկը `__proto__` հատուկ անունն օգտագործելն է, այսպես.

```js run
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

*!*
rabbit.__proto__ = animal; // սահմանում է rabbit.[[Prototype]] = animal
*/!*
```

Այժմ, եթե մենք կարդում ենք հատկությունը `rabbit`-ից, և այն բացակայում է, JavaScript-ն այն ավտոմատ կերպով կվերցնի `animal`-ից:

Օրինակ․

```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

*!*
rabbit.__proto__ = animal; // (*)
*/!*

// Այժմ rabbit-ի մեջ մենք կարող ենք գտնել երկու հատկություն.
*!*
alert( rabbit.eats ); // true (**)
*/!*
alert( rabbit.jumps ); // true
```

Այստեղ `(*)` տողը սահմանում է `animal`-ը որպես `rabbit`-ի նախատիպ:

Այնուհետև, երբ `alert`-ը փորձում է ընթերցել `rabbit.eats` հատկությունը՝ `(**)`, այն բացակայում է `rabbit`-ից, ուստի JavaScript-ը հետևում է `[[Prototype]]` հղմանը և գտնում այն `animal`-ում (նայեք ներքևից վերև):

![](proto-animal-rabbit.svg)

Այստեղ կարելի է ասել, որ «`animal`-ը `rabbit`-ի նախատիպն է» կամ «`rabbit`-ը նախատիպային ժառանգություն է ստանում `animal`-ից»:

Այսպիսով, եթե `animal`-ն ունի շատ օգտակար հատկություններ և մեթոդներ, ապա դրանք ավտոմատ կերպով հասանելի են դառնում `rabbit`-ում: Նման հատկությունները կոչվում են «ժառանգված»:

Եթե մենք ունենք մեթոդ `animal`-ում, այն կարող է կանչվել `rabbit`-ում.

```js run
let animal = {
  eats: true,
*!*
  walk() {
    alert("Animal walk");
  }
*/!*
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// walk-ը վերցված է նախատիպից
*!*
rabbit.walk(); // Animal walk
*/!*
```

Մեթոդն ավտոմատ կերպով վերցված է նախատիպից, այսպես.

![](proto-animal-rabbit-walk.svg)

Նախատիպային շղթան կարող է լինել ավելի երկար.

```js run
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
*!*
  __proto__: animal
*/!*
};

let longEar = {
  earLength: 10,
*!*
  __proto__: rabbit
*/!*
};

// walk-ը վերցված է նախատիպային շղթայից
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (rabbit-ից)
```

![](proto-animal-rabbit-chain.svg)

Այժմ, եթե մենք ինչ-որ բան կարդում ենք `longEar`-ից, իսկ այն բացակայում է, ապա JavaScript-ը այն կփնտրի `rabbit`-ում, այնուհետև `animal`-ում:

Միայն երկու սահմանափակում կա.

1. Հղումները չեն կարող շրջանաձև շրջվել: JavaScript-ը սխալ կթողարկի, եթե փորձենք վերագրել `__proto__`-ն շրջանաձև:
2. `__proto__`-ի արժեքը կարող է լինել կամ օբյեկտ կամ `null`: Մյուս տեսակներն անտեսվում են:

Սա նույնպես ակնհայտ է, այնուամենայնիվ. կարող է լինել միայն մեկ `[[Prototype]]`: Օբյեկտը չի կարող ժառանգվել երկու տարբեր օբյեկտներից:

```smart header="`__proto__`-ն պատմական գեթթեր/սեթթեր է `[[Prototype]]`-ի համար"
Այս երկուսի տարբերության մասին չիմանալը տարածված սխալ է սկսնակ ծրագրավորողների մոտ:

Նկատի ունեցեք, որ `__proto__`-ն *նույնը չէ*, ինչ ներքին `[[Prototype]]` հատկությունը: Այն գեթթեր/սեթթեր է `[[Prototype]]`-ի համար: Ավելի ուշ մենք կտեսնենք իրավիճակներ, որտեղ դա կարևոր է, առայժմ եկեք պարզապես հիշենք այն, քանի որ զարգացնում ենք JavaScript լեզվի մեր ըմբռնումը:

`__proto__` հատկությունը մի փոքր հնացած է և այն գոյություն ունի պատմական պատճառներով։ Ժամանակակից JavaScript-ը առաջարկում է, որ մենք պետք է նախատիպը ստանալու/տեղադրելու փոխարեն օգտագործենք `Object.getPrototypeOf/Object.setPrototypeOf` ֆունկցիաները: Ավելի ուշ այս ֆունկցիաներին ևս կանդրադառնանք:

Ըստ հատկորոշման `__proto__`-ն պետք է սպասարկվի միայն բրաուզերների կողմից: Այնուամենայնիվ, իրականում բոլոր միջավայրերը, ներառյալ սերվերի կողմը, սպասարկում են `__proto__`-ն, այնպես որ մենք բավականին ապահով ենք այն օգտագործելու հարցում:

Քանի որ `__proto__` նշանագրությունը մի փոքր ավելի ինտուիտիվորեն ակնհայտ է, մենք այն օգտագործում ենք օրինակներում:
```

## Գրառման գործողությունը չի օգտագործում նախատիպ

Նախատիպը օգտագործվում է միայն հատկություններն ընթերցելու համար:

Գրելու/ջնջելու գործողությունները ուղղակիորեն աշխատում են օբյեկտի հետ:

Ստորև բերված օրինակում մենք վերագրում ենք իր `walk` մեթոդը `rabbit`-ին.

```js run
let animal = {
  eats: true,
  walk() {
    /* այս մեթոդը չի օգտագործվի rabbit-ում */  
  }
};

let rabbit = {
  __proto__: animal
};

*!*
rabbit.walk = function() {
  alert("Rabbit! Bounce-bounce!");
};
*/!*

rabbit.walk(); // Rabbit! Bounce-bounce!
```

Այսուհետ, `rabbit.walk()` կանչը գտնում է մեթոդն անմիջապես օբյեկտում և կատարում այն՝ առանց նախատիպի օգտագործման.

![](proto-animal-rabbit-walk-2.svg)

Մուտքային հատկությունները բացառություն են, քանի որ նշանակումը իրագործվում է տեղադրող (սեթթեր) ֆունկցիայի միջոցով։ Այսպիսով, նման հատկություն գրելը իրականում նույնն է, ինչ ֆունկցիա կանչելը:

Այդ պատճառով `admin.fullName`-ը ճիշտ է աշխատում ստորև նշված կոդում.

```js run
let user = {
  name: "Մեսրոպ",
  surname: "Մաշտոց",

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

let admin = {
  __proto__: user,
  isAdmin: true
};

alert(admin.fullName); // Մեսրոպ Մաշտոց (*)

// աշխատում է սեթթերը
admin.fullName = "Գասպար Գալենտերյան"; // (**)

alert(admin.fullName); // Գասպար Գալենտերյան, admin-ի վիճակը փոփոխվել է
alert(user.fullName); // Մեսրոպ Մաշտոց, user-ի վիճակը պաշտպանված է
```

Այստեղ `(*)` տողում `admin.fullName` հատկությունը `user` նախատիպի մեջ ունի գեթթեր, ուստի այն կանչվում է:

## «this»-ի արժեքը

Հետաքրքիր հարց կարող է ծագել վերը նշված օրինակում. ո՞րն է `this`-ի արժեքը `set fullName(value)`-ի ներսում: Որտե՞ղ են `this.name` և `this.surname` հատկությունները գրված՝ `user`-ո՞ւմ, թե՞ `admin`-ում:

Պատասխանը պարզ է. `this`-ի վրա նախատիպերն ընդհանրապես չեն ազդում:

**Կարևոր չէ, թե մեթոդը որտեղ է գտնվում՝ օբյեկտում, թե դրա նախատիպում: Մեթոդի կանչում `this`-ը միշտ օբյեկտ է կետից առաջ:**

Այսպիսով, սեթթերի կանչն `admin.fullName=` օգտագործում է `admin`-ը որպես `this`, այլ ոչ `user`-ը։

Դա իրականում գերկարևոր բան է, քանի որ մենք կարող ենք ունենալ մեծ օբյեկտ՝ բազմաթիվ մեթոդներով, և ունենալ օբյեկտներ, որոնք ժառանգում են դրանից։ Եվ երբ ժառանգական օբյեկտները գործարկեն ժառանգված մեթոդները, նրանք կփոփոխեն միայն իրենց վիճակը, այլ ոչ թե մեծ օբյեկտի վիճակը:

Օրինակի համար, այստեղ `animal`-ը ներկայացնում է «մեթոդների պահեստ», իսկ `rabbit`-ն օգտվում է դրանից:

Այս `rabbit.sleep()` կանչը տեղադրում է `this.isSleeping` մեր `rabbit` օբյեկտում․

```js run
// animal-ն ունի մեթոդներ
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`Ես քայլում եմ`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};

let rabbit = {
  name: "Սպիտակ Ճագար",
  __proto__: animal
};

// փոփոխում է rabbit.isSleeping-ը
rabbit.sleep();

alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined (նախատիպում նման հատկություն չկա)
```

Արդյունքում ստացված պատկերը.

![](proto-animal-rabbit-walk-3.svg)

Եթե մենք ունենայինք այլ օբյեկտներ, օրինակ՝ `bird`, `snake` և այլն, որոնք ժառանգեին `animal`-ից, նրանք նույնպես հասանելիություն կունենային `animal`-ի մեթոդներին: Բայց `this`-ը յուրաքանչյուր մեթոդի կանչում կլինի համապատասխան օբյեկտը (կետից առաջ), որի համար տեղի է ունենում կանչը, այլ ոչ `animal`-ը: Այսպիսով, երբ տվյալները գրում ենք `this`-ի մեջ, դրանք պահվում են այդ օբյեկտներում:

Արդյունքում, մեթոդները համօգտագործվող են, իսկ օբյեկտի վիճակը՝ ոչ:

## for..in ցիկլ

`for..in` ցիկլը ժառանգված հատկությունների համար նույնպես կրկնվում է:

Օրինակ․

```js run
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

*!*
// Object.keys-ը վերադարձնում է միայն սեփական բանալիները
alert(Object.keys(rabbit)); // jumps
*/!*

*!*
// for..in-ը կրկնվում է թե՛ սեփական, թե՛ ժառանգված բանալիների համար
for(let prop in rabbit) alert(prop); // jumps, հետո eats
*/!*
```

Եթե դա այն չէ, ինչ մենք ուզում ենք և ցանկանում ենք բացառել ժառանգական հատկությունները, ապա կա ներկառուցված մեթոդ՝ [obj.hasOwnProperty(key)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty), այն վերադարձնում է `true`, եթե `obj`-ն ունի իր սեփական (չժառանգված) հատկությունը՝ `key` անվանումով։

Այսպիսով, մենք կարող ենք զտել ժառանգված հատկությունները (կամ որևէ այլ գործողություն անել դրանց հետ).

```js run
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  if (isOwn) {
    alert(`Սեփական՝ ${prop}`); // Սեփական՝ jumps
  } else {
    alert(`Ժառանգված՝ ${prop}`); // Ժառանգված՝ eats
  }
}
```

Այստեղ մենք ունենք հետևյալ ժառանգական շղթան. `rabbit`-ը ժառանգում է `animal`-ից, որը ժառանգում է `Object.prototype`-ից (քանի որ `animal`-ը բառացի օբյեկտ է `{...}`, ուստի դա լռելյայն է), այնուհետև `null` է դրա վերևում․

![](rabbit-animal-object.svg)

Նկատի ունեցեք, կա մի ծիծաղելի բան. որտեղի՞ց է գալիս `rabbit.hasOwnProperty` մեթոդը: Մենք այն չենք սահմանել։ Նայելով շղթային՝ կարող ենք տեսնել, որ մեթոդը տրամադրվում է `Object.prototype.hasOwnProperty`-ի կողմից: Այլ կերպ ասած, դա ժառանգական է:

...Բայց ինչո՞ւ `hasOwnProperty`-ն չի հայտնվում `for..in` ցիկլում՝ ինչպես `eats`-ը և `jumps`-ը, եթե `for..in`-ը թվարկում է նաև ժառանգված հատկությունները:

Պատասխանը պարզ է․ այն թվարկելի չէ։ Ինչպես `Object.prototype`-ի մյուս հատկությունները, սա էլ ունի `enumerable:false` դրոշակ։
Իսկ `for..in`-ը միայն թվարկում է թվարկելի հատկությունները։ Դա է պատճառը, որ այս և մնացած `Object.prototype`-ի հատկությունները թվարկված չեն:

```smart header="Գրեթե բոլոր մյուս բանալի/արժեք ստացող մեթոդները անտեսում են ժառանգված հատկությունները"
Գրեթե բոլոր մյուս բանալի/արժեք ստացող մեթոդները, ինչպիսիք են `Object.keys`, `Object.values` և այլն, անտեսում են ժառանգված հատկությունները:

Նրանք ազդում են միայն բուն օբյեկտի վրա: Նախատիպի հատկությունները հաշվի *չեն* առնվում:
```

## Ամփոփում

- JavaScript-ում բոլոր օբյեկտներն ունեն թաքնված `[[Prototype]]` հատկություն, որը կամ այլ օբյեկտ է, կամ `null`:
- Մուտք ունենալու համար մենք կարող ենք օգտագործել `obj.__proto__` (պատմական գեթթեր/սեթթեր, կան նաև այլ ճանապարհներ, որոնք շուտով կլուսաբանվեն)։
- `[[Prototype]]`-ի կողմից հղված օբյեկտը կոչվում է «նախատիպ»:
- Եթե ցանկանում ենք ընթերցել `obj`-ի հատկությունը կամ կանչել մեթոդը, իսկ այն գոյություն չունի, ապա JavaScript-ը փորձում է գտնել այն նախատիպում։
- Գրառման/ջնջելու գործողությունները ազդում են անմիջապես օբյեկտի վրա, նրանք չեն օգտագործում նախատիպը (ենթադրելով, որ դա տվյալային հատկություն է, այլ ոչ թե սեթթեր)։
- Եթե մենք կանչենք `obj.method()`, իսկ `method`-ը վերցված լինի նախատիպից, `this`-ը միևնույնն է, հղում է անում `obj`-ին։ Այսպիսով, մեթոդները միշտ աշխատում են ընթացիկ օբյեկտի հետ, նույնիսկ եթե դրանք ժառանգված են:
- `for..in` ցիկլը կրկնվում է ինչպես իր սեփական, այնպես էլ ժառանգված հատկությունների համար: Մյուս բոլոր բանալի/արժեք ստանալու մեթոդները գործում են միայն բուն օբյեկտի համար:
