# F.prototype

Հիշեք՝ նոր օբյեկտներ կարող են ստեղծվել կոնստրուկտոր ֆունկցիայով, այսպես՝ `new F()`։

Եթե `F.prototype`-ը օբյեկտ է, ապա `new` օպերատորն այն օգտագործում է նոր օբյեկտի համար `[[Prototype]]` տեղադրելու նպատակով։

```smart
JavaScript-ն ի սկզբանե ուներ նախատիպային ժառանգություն: Դա լեզվի առանցքային առանձնահատկություններից մեկն էր:

Բայց հին ժամանակներում դրան անմիջական մուտք չկար։ Միակ բանը, որն աշխատում էր հուսալիորեն, այս գլխում նկարագրված կոնստրուկտոր ֆունկցիայի `«prototype»` հատկությունն էր: Այնպես որ, շատ սքրիփթներ կան, որտեղ դեռ օգտագործվում է այն:
```

Նկատի ունեցեք, որ `F.prototype`-ը այստեղ նշանակում է `«prototype»` անվանումով սովորական հատկություն `F`-ի համար. Այն հնչում է որպես «prototype» տերմինի նման մի բան, բայց այստեղ մենք իսկապես նկատի ունենք այս անվանումով սովորական հատկություն:

Ահա օրինակը.

```js run
let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

*!*
Rabbit.prototype = animal;
*/!*

let rabbit = new Rabbit("Սպիտակ Ճագար"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // true
```

`Rabbit.prototype = animal` կարգավորումը բառացիորեն նշում է հետևյալը. «երբ `new Rabbit` ստեղծվի, նրա `[[Prototype]]`-ը նշանակել `animal`-ին»։

Ստացված պատկերն այսպիսին է.

![](proto-constructor-animal-rabbit.svg)

Նկարում `«prototype»`-ը հորիզոնական սլաք է, որը նշանակում է կանոնավոր հատկություն, իսկ `[[Prototype]]`-ը ուղղահայաց է՝ նշանակում է `rabbit`-ի ժառանգությունը `animal`-ից:

```smart header="`F.prototype`-ը միայն օգտագործվում է `new F`-ի ժամանակ"
`F.prototype` հատկությունն օգտագործվում է միայն այն դեպքում, երբ `new F` է կանչվում, այն նշանակում է `[[Prototype]]` նոր օբյեկտին։

Եթե ստեղծելուց հետո `F.prototype` հատկությունը փոփոխվի (`F.prototype = <այլ օբյեկտ>`), ապա `new F`-ի կողմից ստեղծված նոր օբյեկտները կունենան մեկ այլ օբյեկտ որպես `[[Prototype]]`, բայց արդեն գոյություն ունեցող օբյեկտները կպահպանեն հինը։
```

## Կանխադրված F.prototype, constructor հատկություն

Յուրաքանչյուր ֆունկցիա ունի `«prototype»` հատկություն, նույնիսկ, եթե մենք չտրամադրենք այն:

Կանխադրված `«prototype»`-ն օբյեկտ է, որն ունի միայն մեկ հատկություն՝ `constructor`, որն էլ իր հերթին հղում է կատարում բուն ֆունկցիային։

Այսպես.

```js
function Rabbit() {}

/* կանխադրված prototype-ը
Rabbit.prototype = { constructor: Rabbit };
*/
```

![](function-prototype-constructor.svg)

Մենք կարող ենք ստուգել այն.

```js run
function Rabbit() {}
// կանխադրված․
// Rabbit.prototype = { constructor: Rabbit }

alert( Rabbit.prototype.constructor == Rabbit ); // true
```

Բնականաբար, եթե մենք ոչինչ չանենք, `constructor` հատկությունը հասանելի կլինի բոլոր ճագարներին `[[Prototype]]`-ի միջոցով.

```js run
function Rabbit() {}
// կանխադրված․
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // ժառանգում է {constructor: Rabbit}-ից

alert(rabbit.constructor == Rabbit); // true (prototype-ից)
```

![](rabbit-prototype-constructor.svg)

Մենք կարող ենք օգտագործել արդեն իսկ գոյություն ունեցող օբյեկտի `constructor` հատկությունը՝ նորը ստեղծելու համար։

Ինչպես այստեղ․

```js run
function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit("Սպիտակ Ճագար");

*!*
let rabbit2 = new rabbit.constructor("Սև Ճագար");
*/!*
```

Դա հարմար է, երբ մենք ունենք օբյեկտ, բայց չգիտենք, թե որ կոնստրուկտորն է օգտագործվել դրա համար (օրինակ՝ այն ստեղծվել է կողմնակի գրադարանից), իսկ մեզ պետք է ստեղծել նույն տեսակից ևս մեկը:

Բայց `«constructor»`-ի մասին, հավանաբար, ամենակարևորն այն է, որ...

**...JavaScript-ն ինքնին չի ապահովում `«constructor»`-ի ճշգրիտ արժեքը։**

Այո, այն գոյություն ունի ֆունկցիաների կանխադրված `«prototype»`-ում, բայց միայն այդքանը։ Այն, ինչ տեղի կունենա դրա հետ հետագայում, ամբողջովին մեզանից է կախված:

Մասնավորապես, եթե մենք ամբողջությամբ փոխարինենք կանխադրված նախատիպը, ապա դրանում `«constructor»` չի լինի:

Օրինակ․

```js run
function Rabbit() {}
Rabbit.prototype = {
  jumps: true
};

let rabbit = new Rabbit();
*!*
alert(rabbit.constructor === Rabbit); // false
*/!*
```

Այսպիսով, ճշգրիտ `«constructor»`-ը պահելու համար մենք կարող ենք ավելացնել/հեռացնել հատկություններ կանխադրված `«prototype»`-ում՝ այն ամբողջությամբ վերագրելու փոխարեն.

```js
function Rabbit() {}

// Չենք վերագրում Rabbit.prototype-ն ամբողջությամբ
// ավելացնում ենք նրանում
Rabbit.prototype.jumps = true
// կանխադրված Rabbit.prototype.constructor-ը պահպանված է
```

Կամ, որպես այլընտրանք, հենց մենք վերստեղծեք `constructor` հատկությունը.

```js
Rabbit.prototype = {
  jumps: true,
*!*
  constructor: Rabbit
*/!*
};

// այժմ կոնստրուկտորը նույնպես ճշգրիտ է, քանի որ մենք այն ավելացրեցինք
```


## Ամփոփում

Այս գլխում մենք հակիրճ նկարագրեցինք `[[Prototype]]` սահմանելու եղանակը կոնստրուկտոր ֆունկցիայի միջոցով ստեղծված օբյեկտների համար:
Ավելի ուշ մենք կծանոթանանք ծրագրավորման ավելի ընդլայնված օրինաչափություններին, որոնք հիմնված են դրա վրա:

Ամեն ինչ բավականին պարզ է, ընդամենը մի քանի նշում՝ ամեն ինչ էլ ավելի պարզ դարձնելու համար.

- `F.prototype` հատկությունը (մի շփոթեք այն `[[Prototype]]`-ի հետ) նոր օբյեկտների համար `[[Prototype]]` է սահմանում, երբ կանչվում է `new F()`-ը։
- `F.prototype`-ի արժեքը պետք է լինի կամ օբյեկտ կամ `null`. մյուս արժեքները չեն աշխատի:
-  `«prototype»` հատկությունը հատուկ էֆեկտ է ունենում միայն այն դեպքում, երբ տեղադրված է կոնստրուկտոր ֆունկցիայի համար, որը գործարկվում է `new`-ով։

Սովորական օբյեկտների համար `prototype`-ը առանձնահատուկ բան չէ.
```js
let user = {
  name: "John",
  prototype: "Bla-bla" // ոչ մի կախարդանք
};
```

Կանխադրված կերպով բոլոր ֆունկցիաներն ունեն `F.prototype = { constructor: F }`, այնպես որ մենք կարող ենք ստանալ օբյեկտի կոնստրուկտորը՝ մուտք գործելով նրա `«constructor»` հատկությանը։
